#lang racket/base
(require (for-syntax racket/base
                     racket/syntax
                     syntax/parse)
         adqc
         chk
         racket/match
         racket/port)

(define (raw-value v)
  (match v
    [(or (Int _ _ val) (Flo _ val))
     val]))

(define (TProg1* stx the-p the-cp n args expect-ans)
  (define eval-ans #f)
  (define comp-ans #f)
  (chk #:t (#:src stx (set! eval-ans (eval-program the-p n args))))
  (when (and expect-ans eval-ans)
    (chk (#:src stx eval-ans)
         (#:src stx expect-ans)))
  (unless the-cp
    (chk #:t (set! the-cp (link-program the-p))))
  (when the-cp
    (define (print-src _)
      (match-define (linked-program _ _ src-path) the-cp)
      (define src (port->string (open-input-file src-path)))
      (display src (current-error-port)))
    (with-chk ([chk-inform! print-src])
      (chk #:t (set! comp-ans (run-linked-program the-cp n (map raw-value args))))
      (when comp-ans (chk #:= comp-ans (raw-value eval-ans))))))
(define-syntax (TProg1 stx)
  (syntax-parse stx
    [(_ the-p:id
        (~optional (~seq #:compiled compiled-p:id)
                   #:defaults ([compiled-p #''#f]))
        . t)
     #:with (n:expr (~and arg-e (~not (~datum =>))) ...
                    (~optional (~seq (~datum =>) ans (~bind [ans-e #'(E ans)]))
                               #:defaults ([ans-e #'#f]))) #'t
     (quasisyntax/loc stx
       (TProg1* #'t the-p compiled-p n (list (E arg-e) ...) ans-e))]))
(define-syntax (TProgN stx)
  (syntax-parse stx
    [(_ the-p:id
        (~optional (~seq #:compiled compiled-p:id)
                   #:defaults ([compiled-p #f]))
        t ...)
     (syntax/loc stx
       (begin (TProg1 the-p (~@ . (~? (#:compiled compiled-p) ())) . t)
              ...))]))
(define-syntax (TProg stx)
  (syntax-parse stx
    [(_ p-body ... #:tests t ...)
     (quasisyntax/loc stx
       (let ([the-p #f]
             [the-cp #f])
         (chk #:t (set! the-p (Prog p-body ...)))
         (chk #:t (set! the-cp (link-program the-p)))
         (TProgN the-p #:compiled the-cp t ...)))]))
(define-syntax (TS stx)
  (syntax-parse stx
    [(_ the-s (~optional (~seq ans)
                         #:defaults ([ans #f])))
     #:with f (generate-temporary)
     (quasisyntax/loc stx
       ;; XXX Once type inference is implemented, just drop this S64
       (TProg (define-fun (f) : S64 the-s)
              #:tests
              #,(syntax/loc stx
                  [(symbol->string 'f) (~@ . (~? (=> ans) ()))])))]))
(define-syntax (TE stx)
  (syntax-parse stx
    [(_ the-e (~optional ans
                         #:defaults ([ans #f])))
     #:with f (generate-temporary)
     (syntax/loc stx
       (TS the-e (~@ . (~? (ans) ()))))]))
(provide TProg1 TProgN TProg TS TE)

(module+ test
  (chk*
   (TE (S64 5) (S64 5))
   (TS (let ([x : S64 := (S64 5)]) x) (S64 5))
   (TE (iadd (S64 5) (S64 6)) (S64 11))
   (TS (begin (define x : S64 := (S64 5))
              (define y : S64 := (S64 6))
              (iadd x y)) (S64 11))
   (TE (isub (S64 6) (S64 5)) (S64 1))
   (TE (imul (S64 3) (S64 4)) (S64 12))
   (TE (iudiv (U64 100) (U64 10)) (U64 10))
   (TE (iudiv (S8 -2) (S8 2)) (S8 127))
   (TE (iudiv (S8 -1) (S8 2)) (S8 127))
   (TE (isdiv (S64 13) (S64 4)) (S64 3))
   (TE (isdiv (S64 12) (S64 4)) (S64 3))
   (TE (isrem (S64 12) (S64 5)) (S64 2))
   (TE (iurem (U64 105) (U64 10)) (U64 5))
   (TE (iurem (S8 -1) (S8 2)) (S8 1))
   (TE (iurem (S8 -2) (S8 2)) (S8 0))
   (TE (ishl (S64 2) (S64 1)) (S64 4))
   (TE (iashr (S64 4) (S64 1)) (S64 2))
   (TE (iashr (S8 -128) (S8 2)) (S8 -32) )
   (TE (ilshr (S8 -128) (S8 2)) (S8 32))
   (TE (ilshr (U8 16) (U8 2)) (U8 4))
   (TE (ior (S64 1) (S64 2)) (S64 3))
   (TE (ior (U8 1) (U8 2)) (U8 3))
   (TE (iand (S64 3) (S64 1)) (S64 1))
   (TE (iand (U8 3) (U8 1)) (U8 1))
   (TE (ixor (S64 3) (S64 2)) (S64 1))
   (TE (ixor (U8 3) (U8 2)) (U8 1))
   ;; Integer comparison
   (TE (ieq (S64 1) (S64 1)) (S64 1))
   (TE (ieq (S64 1) (S64 2)) (S64 0))
   (TE (ine (S64 1) (S64 2)) (S64 1))
   (TE (ine (S64 1) (S64 1)) (S64 0))
   (TE (iugt (U8 5) (U8 4)) (U8 1))
   (TE (iugt (U8 4) (U8 5)) (U8 0))
   (TE (iugt (S8 -1) (S8 0)) (S8 1))
   (TE (isgt (S8 1) (S8 0)) (S8 1))
   (TE (isgt (S8 0) (S8 1)) (S8 0))
   (TE (isgt (S8 0) (S8 -1)) (S8 1))
   (TE (iuge (U8 1) (U8 1)) (U8 1))
   (TE (iuge (S8 -1) (S8 0)) (S8 1))
   (TE (isge (S8 1) (S8 1)) (S8 1))
   (TE (isge (S8 1) (S8 -1))(S8 1))
   (TE (iult (U8 4) (U8 5)) (U8 1))
   (TE (iult (U8 5) (U8 4)) (U8 0))
   (TE (iult (S8 0) (S8 -1)) (S8 1))
   (TE (islt (S8 0) (S8 1)) (S8 1))
   (TE (islt (S8 1) (S8 0)) (S8 0))
   (TE (islt (S8 -1) (S8 0))(S8 1))
   (TE (iule (U8 1) (U8 1)) (U8 1))
   (TE (iule (S8 0) (S8 -1))(S8 1))
   (TE (isle (S8 1) (S8 1)) (S8 1))
   (TE (isle (S8 -1) (S8 1)) (S8 1))
   ;; Floating point arithmetic
   (TE (fadd (F64 2.0) (F64 1.5)) (F64 3.5))
   (TE (fsub (F64 6.1) (F64 0.1)) (F64 6.0))
   (TE (fmul (F64 1.5) (F64 1.5)) (F64 2.25))
   (TE (fdiv (F64 9.0) (F64 1.5)) (F64 6.0))
   (TE (frem (F64 5.3) (F64 2.0)) (F64 1.2999999999999998))
   ;; Floating point comparisons
   (TE (ffalse (F64 +nan.0) (F64 +nan.0)) (U32 0))
   (TE (ftrue (F64 +nan.0) (F64 +nan.0)) (U32 1))
   (TE (foeq (F64 1.0) (F64 1.0)) (U32 1))
   (TE (foeq (F64 1.0) (F64 2.0)) (U32 0))
   (TE (foeq (F64 1.0) (F64 +nan.0)) (U32 0))
   (TE (fogt (F64 1.0) (F64 0.0)) (U32 1))
   (TE (fogt (F64 0.0) (F64 1.0)) (U32 0))
   (TE (fogt (F64 1.0) (F64 +nan.0)) (U32 0))
   (TE (foge (F64 1.0) (F64 1.0)) (U32 1))
   (TE (foge (F64 0.0) (F64 1.0)) (U32 0))
   (TE (foge (F64 1.0) (F64 +nan.0)) (U32 0))
   (TE (folt (F64 0.0) (F64 1.0)) (U32 1))
   (TE (folt (F64 1.0) (F64 0.0)) (U32 0))
   (TE (folt (F64 1.0) (F64 +nan.0)) (U32 0))
   (TE (fole (F64 1.0) (F64 1.0)) (U32 1))
   (TE (fole (F64 1.0) (F64 0.0)) (U32 0))
   (TE (fole (F64 1.0) (F64 +nan.0)) (U32 0))
   (TE (fone (F64 1.0) (F64 1.0)) (U32 0))
   (TE (fone (F64 0.0) (F64 1.0)) (U32 1))
   (TE (fone (F64 1.0) (F64 +nan.0)) (U32 0))
   (TE (ford (F64 1.0) (F64 1.0)) (U32 1))
   (TE (ford (F64 1.0) (F64 +nan.0)) (U32 0))
   (TE (fueq (F64 1.0) (F64 1.0)) (U32 1))
   (TE (fueq (F64 0.0) (F64 1.0)) (U32 0))
   (TE (fueq (F64 1.0) (F64 +nan.0)) (U32 1))
   (TE (fugt (F64 1.0) (F64 0.0)) (U32 1))
   (TE (fugt (F64 0.0) (F64 1.0)) (U32 0))
   (TE (fugt (F64 1.0) (F64 +nan.0)) (U32 1))
   (TE (fuge (F64 1.0) (F64 1.0)) (U32 1))
   (TE (fuge (F64 0.0) (F64 1.0)) (U32 0))
   (TE (fuge (F64 1.0) (F64 +nan.0)) (U32 1))
   (TE (fult (F64 0.0) (F64 1.0)) (U32 1))
   (TE (fult (F64 1.0) (F64 0.0)) (U32 0))
   (TE (fult (F64 1.0) (F64 +nan.0)) (U32 1))
   (TE (fule (F64 1.0) (F64 1.0)) (U32 1))
   (TE (fule (F64 1.0) (F64 0.0)) (U32 0))
   (TE (fule (F64 1.0) (F64 +nan.0)) (U32 1))
   (TE (fune (F64 0.0) (F64 1.0)) (U32 1))
   (TE (fune (F64 1.0) (F64 1.0)) (U32 0))
   (TE (fune (F64 1.0) (F64 +nan.0)) (U32 1))
   (TE (fueq (F64 1.0) (F64 1.0)) (U32 1))
   (TE (fueq (F64 0.0) (F64 1.0)) (U32 0))
   (TE (fueq (F64 1.0) (F64 +nan.0)) (U32 1))
   (TE (funo (F64 1.0) (F64 +nan.0)) (U32 1))
   (TE (funo (F64 1.0) (F64 2.0)) (U32 0))
   ;; Cast
   (TE ((S8 23) : U32) (U32 23))
   (TE ((F64 23.3) : F32) (F32 23.3f0))
   (TE ((F64 23.3) : S32) (S32 23))
   (TE ((S32 23) : F64) (F64 23.0))
   ;; XXX How to test Fail?

   (TS (let ([x : S64 := (S64 1)])
         (void)
         x)
       (S64 1))
   (TS (let ([x : S64 := (S64 1)])
         {x <- (S64 5)}
         x)
       (S64 5))
   (TS (let ([x : S64 := (S64 1)])
         {x <- (iadd (S64 5) (S64 6))}
         x)
       (S64 11))
   (TS (begin (define x : S64 := (S64 0))
              (define y : S64 := (S64 0))
              {x <- (S64 1)} {y <- (S64 2)}
              (iadd x y))
       (S64 3))
   (TS (begin (define x : S64 := (S64 0))
              (define y : S64 := (S64 0))
              (if (ieq (S64 0) (S64 0))
                  {x <- (S64 1)}
                  {y <- (S64 2)})
              (iadd x y))
       (S64 1))
   (TS (begin (define x : S64 := (S64 0))
              (define y : S64 := (S64 0))
              (if (ieq (S64 0) (S64 1))
                  {x <- (S64 1)}
                  {y <- (S64 2)})
              (iadd x y))
       (S64 2))
   (TS (begin (define x : S64 := (S64 0))
              (while (islt x (S64 5))
                     {x <- (iadd x (S64 1))})
              x)
       (S64 5))
   (TS (begin (define x : S64 := (S64 0))
              (define y : S64 := (S64 0))
              (while (islt x (S64 5))
                     {y <- (iadd y x)}
                     {x <- (iadd x (S64 1))})
              y)
       (S64 (+ (+ (+ (+ (+ 0 0) 1) 2) 3) 4)))

   (TS (begin
         (define x : S32 := (S32 0))
         (define y : S32 := (S32 1))
         (set! x (S32 0))
         (void)
         (unless (ieq x (S32 0))
           (error "The world is upside-down!"))
         (let/ec end
           (assert! #:dyn #:msg "y is positive"
                    (iult (S32 0) y))
           (if (ieq (S32 5) (S32 6))
               (set! x (S32 1))
               (set! y (S32 2)))
           (when (ieq y (S32 2))
             (set! x (S32 1))
             (end))
           (while (iult x (S32 6))
                  (set! x (iadd x (S32 1)))))
         (set! y (S32 42))
         (iadd x y))
       (S32 43))

   (TS (begin
         (define x : U32 := (U32 0))
         {x <- (U32 100)}
         x)
       (U32 100))
   (TS (return (if (islt (U32 5) (U32 6))
                   (iadd (S64 2) (S64 3))
                   (isub (S64 5) (S64 6))))
       (S64 5))
   (TS (return (let ([x : U32 := (U32 5)])
                 (iadd x (U32 1))))
       (U32 6))
   (TS (begin (define my-array : (array 3 U32) := (array (U32 0) (U32 1) (U32 2)))
              (iadd (my-array @ (U32 0))
                    (iadd (my-array @ (U32 1))
                          (my-array @ (U32 2)))))
       (U32 (+ 0 1 2)))
   (TS (begin (define y : S32 := (S32 5))
              (define my-array : (array 3 S32) := (zero (array 3 S32)))
              {y <- (iadd y (my-array @ (U32 2)))}
              y)
       (S32 5))
   ))
