#lang racket/base
(require (for-syntax racket/base
                     racket/syntax)
         adqc
         chk
         racket/match
         racket/stxparam
         syntax/parse/define)

;; This assumes the same representation used by the evaluator for data types.
(define (raw-value ty v)
  (match ty
    [(? IntT?) (Int-val v)]
    [(? FloT?) (Flo-val v)]
    [(RecT f->ty _ c-order)
     (for/list ([f (in-list c-order)])
       (raw-value (hash-ref f->ty f) (unbox (hash-ref v f))))]
    [(ArrT dim ety)
     (for/vector #:length dim ([v* (in-vector v)])
       (raw-value ety (unbox v*)))]
    ;; XXX Structs and Unions.
    ))

(define current-invert? (make-parameter #f))
(define-syntax-rule (! . b)
  (parameterize ([current-invert? #t]) . b))

(define ((print-src! c-path) _)
  (define in (open-input-file c-path))
  (for ([ch (in-port read-char in)])
    (display ch (current-error-port)))
  (newline (current-error-port))
  (close-input-port in))

(define (TProg1* stx the-p the-cp c-path n args-i expect-ans-i)
  ;; Get type info for args and ans.
  (define the-fun (unpack-MetaFun (hash-ref (Program-name->fun the-p) n)))
  (match-define (IntFun (list (Arg _ arg-tys _) ...) _ ans-ty _ _)
    the-fun)
  (define args (for/list ([ai (in-list args-i)])
                 (unbox (eval-init (hash) ai))))
  (define eval-expect-ans (unpack-MetaE
                           (unbox (eval-init (hash) expect-ans-i))))
  (define eval-ans #f)
  (define comp-ans #f)
  (define (print-the-fun! _)
    (print-ast the-fun (current-error-port))
    (newline (current-error-port)))
  (with-chk ([chk-inform! print-the-fun!])
    (chk #:t (#:src stx (set! eval-ans (unpack-MetaE
                                        (eval-program the-p n args-i)))))
    (when eval-ans
      (chk (#:src stx eval-ans) (#:src stx eval-expect-ans))))
  (unless the-cp
    (chk #:t (set! the-cp (link-program the-p c-path))))
  (when the-cp
    (with-chk ([chk-inform! (print-src! c-path)])
      ;; XXX Once linked-program-write exists, we can automatically
      ;; convert arguments into the data layout expected by linked-program-run.
      (define comp-args (for/list ([a (in-list args)]
                                   [ty (in-list arg-tys)])
                          (raw-value ty a)))
      (chk #:t (#:src stx
                (set! comp-ans (linked-program-run the-cp n comp-args))))
      (when comp-ans
        (define comp-expect-ans (raw-value ans-ty eval-ans))
        (define comp-ans* (linked-program-read the-cp comp-ans))
        (if (current-invert?)
            (chk #:! (#:src stx comp-ans*)
                 (#:src stx comp-expect-ans))
            (chk (#:src stx comp-ans*)
                 (#:src stx comp-expect-ans)))))))

(define-syntax (TProg1 stx)
  (syntax-parse stx
    [(_ the-p:id the-cp:id c-path . t)
     #:with (n:expr (~and arg-e (~not (~datum =>))) ... (~datum =>) ans) #'t
     (syntax/loc stx
       (TProg1* #'t the-p the-cp c-path n (list (I arg-e) ...) (I ans)))]))
(define-syntax (TProgN stx)
  (syntax-parse stx
    [(_ the-p:id t ...)
     (syntax/loc stx
       (with-temp-files (c-path bin-path)
         (define the-cp #f)
         (chk #:t (#:stx #,stx (set! the-cp (link-program the-p c-path bin-path))))
         (TProg1 the-p the-cp c-path . t) ...))]))
(define-syntax (TProg stx)
  (syntax-parse stx
    [(_ p-body ... #:tests t ...)
     (syntax/loc stx
       (let ([the-p #f])
         (chk #:t (#:stx #,stx (set! the-p (Prog p-body ...))))
         (TProgN the-p t ...)))]))
(define-syntax (TS stx)
  (syntax-parse stx
    [(_ the-s ans)
     #:with f (generate-temporary)
     (syntax/loc stx
       (let* ([ans-e (E ans)] [ans-ty (expr-type ans-e)])
         (TProg (define-fun #,ans-ty f () the-s)
                #:tests [(symbol->string 'f) => ans])))]))
(define-simple-macro (TE the-e ans)
  (TS the-e ans))

(define-simple-macro (TT the-ast)
  (chk #:x the-ast exn:fail:adqc:type?))
(define-simple-macro (TTE the-e)
  (TT (E the-e)))
(define-simple-macro (TTS the-s)
  (TT (S the-s)))
(define-simple-macro (TTN expect-ty the-n ...+)
  (begin
    (chk #:x (E (let ([x : expect-ty := #,(N the-n)]) x)) exn:fail?)
    ...))

(provide TProg1 TProgN TProg TS TE TT TTE TTS TTN)

(module+ test
  (chk*
   (TE (S64 5) (S64 5))
   (TS (let ([x : S64 := (S64 5)]) x) (S64 5))
   (TE (iadd (S64 5) (S64 6)) (S64 11))
   (TS (begin (define x : S64 := (S64 5))
              (define y : S64 := (S64 6))
              (iadd x y)) (S64 11))
   (TE (isub (S64 6) (S64 5)) (S64 1))
   (TE (imul (S64 3) (S64 4)) (S64 12))
   (TE (iudiv (U64 100) (U64 10)) (U64 10))
   (TE (isdiv (S64 13) (S64 4)) (S64 3))
   (TE (isdiv (S64 12) (S64 4)) (S64 3))
   (TE (isrem (S64 12) (S64 5)) (S64 2))
   (TE (iurem (U64 105) (U64 10)) (U64 5))
   (TE (ishl (S64 2) (S64 1)) (S64 4))
   (TE (iashr (S64 4) (S64 1)) (S64 2))
   (TE (iashr (S8 -128) (S8 2)) (S8 -32) )
   (TE (ilshr (U8 16) (U8 2)) (U8 4))
   (TE (ior (S64 1) (S64 2)) (S64 3))
   (TE (ior (U8 1) (U8 2)) (U8 3))
   (TE (iand (S64 3) (S64 1)) (S64 1))
   (TE (iand (U8 3) (U8 1)) (U8 1))
   (TE (ixor (S64 3) (S64 2)) (S64 1))
   (TE (ixor (U8 3) (U8 2)) (U8 1))
   ;; Integer comparison
   (TE (ieq (S64 1) (S64 1)) (S32 1))
   (TE (ieq (S64 -1) (S64 2)) (S32 0))
   (TE (ieq (S64 -2) (S64 -2)) (S32 1))
   (TE (ieq (S64 1) (S64 2)) (S32 0))
   (TE (ine (S64 1) (S64 2)) (S32 1))
   (TE (ine (S64 1) (S64 1)) (S32 0))
   (TE (ine (S64 -2) (S64 5)) (S32 1))
   (TE (ine (S64 -2) (S64 -2)) (S32 0))
   (TE (iugt (U8 5) (U8 4)) (S32 1))
   (TE (iugt (U8 4) (U8 5)) (S32 0))
   (TE (isgt (S8 1) (S8 0)) (S32 1))
   (TE (isgt (S8 0) (S8 1)) (S32 0))
   (TE (isgt (S8 0) (S8 -1)) (S32 1))
   (TE (iuge (U8 1) (U8 1)) (S32 1))
   (TE (isge (S8 1) (S8 1)) (S32 1))
   (TE (isge (S8 1) (S8 -1))(S32 1))
   (TE (iult (U8 4) (U8 5)) (S32 1))
   (TE (iult (U8 5) (U8 4)) (S32 0))
   (TE (islt (S8 0) (S8 1)) (S32 1))
   (TE (islt (S8 1) (S8 0)) (S32 0))
   (TE (islt (S8 -1) (S8 0))(S32 1))
   (TE (iule (U8 1) (U8 1)) (S32 1))
   (TE (isle (S8 1) (S8 1)) (S32 1))
   (TE (isle (S8 -1) (S8 1)) (S32 1))
   ;; Floating point arithmetic
   (TE (fadd (F64 2.0) (F64 1.5)) (F64 3.5))
   (TE (fsub (F64 6.1) (F64 0.1)) (F64 6.0))
   (TE (fmul (F64 1.5) (F64 1.5)) (F64 2.25))
   (TE (fdiv (F64 9.0) (F64 1.5)) (F64 6.0))
   (TE (frem (F64 5.3) (F64 2.0)) (F64 1.2999999999999998))
   ;; Floating point comparisons
   (TE (ffalse (F64 +nan.0) (F64 +nan.0)) (S32 0))
   (TE (ftrue (F64 +nan.0) (F64 +nan.0)) (S32 1))
   (TE (foeq (F64 1.0) (F64 1.0)) (S32 1))
   (TE (foeq (F64 1.0) (F64 2.0)) (S32 0))
   (TE (foeq (F64 1.0) (F64 +nan.0)) (S32 0))
   (TE (fogt (F64 1.0) (F64 0.0)) (S32 1))
   (TE (fogt (F64 0.0) (F64 1.0)) (S32 0))
   (TE (fogt (F64 1.0) (F64 +nan.0)) (S32 0))
   (TE (foge (F64 1.0) (F64 1.0)) (S32 1))
   (TE (foge (F64 0.0) (F64 1.0)) (S32 0))
   (TE (foge (F64 1.0) (F64 +nan.0)) (S32 0))
   (TE (folt (F64 0.0) (F64 1.0)) (S32 1))
   (TE (folt (F64 1.0) (F64 0.0)) (S32 0))
   (TE (folt (F64 1.0) (F64 +nan.0)) (S32 0))
   (TE (fole (F64 1.0) (F64 1.0)) (S32 1))
   (TE (fole (F64 1.0) (F64 0.0)) (S32 0))
   (TE (fole (F64 1.0) (F64 +nan.0)) (S32 0))
   (TE (fone (F64 1.0) (F64 1.0)) (S32 0))
   (TE (fone (F64 0.0) (F64 1.0)) (S32 1))
   (TE (fone (F64 1.0) (F64 +nan.0)) (S32 0))
   (TE (ford (F64 1.0) (F64 1.0)) (S32 1))
   (TE (ford (F64 1.0) (F64 +nan.0)) (S32 0))
   (TE (fueq (F64 1.0) (F64 1.0)) (S32 1))
   (TE (fueq (F64 0.0) (F64 1.0)) (S32 0))
   (TE (fueq (F64 1.0) (F64 +nan.0)) (S32 1))
   (TE (fugt (F64 1.0) (F64 0.0)) (S32 1))
   (TE (fugt (F64 0.0) (F64 1.0)) (S32 0))
   (TE (fugt (F64 1.0) (F64 +nan.0)) (S32 1))
   (TE (fuge (F64 1.0) (F64 1.0)) (S32 1))
   (TE (fuge (F64 0.0) (F64 1.0)) (S32 0))
   (TE (fuge (F64 1.0) (F64 +nan.0)) (S32 1))
   (TE (fult (F64 0.0) (F64 1.0)) (S32 1))
   (TE (fult (F64 1.0) (F64 0.0)) (S32 0))
   (TE (fult (F64 1.0) (F64 +nan.0)) (S32 1))
   (TE (fule (F64 1.0) (F64 1.0)) (S32 1))
   (TE (fule (F64 1.0) (F64 0.0)) (S32 0))
   (TE (fule (F64 1.0) (F64 +nan.0)) (S32 1))
   (TE (fune (F64 0.0) (F64 1.0)) (S32 1))
   (TE (fune (F64 1.0) (F64 1.0)) (S32 0))
   (TE (fune (F64 1.0) (F64 +nan.0)) (S32 1))
   (TE (fueq (F64 1.0) (F64 1.0)) (S32 1))
   (TE (fueq (F64 0.0) (F64 1.0)) (S32 0))
   (TE (fueq (F64 1.0) (F64 +nan.0)) (S32 1))
   (TE (funo (F64 1.0) (F64 +nan.0)) (S32 1))
   (TE (funo (F64 1.0) (F64 2.0)) (S32 0))
   ;; Smart ops
   (TE (+ (S32 2) (S32 3)) (S32 5))
   (TE (+ (F32 2.0f0) (F32 2.5f0)) (F32 4.5f0))
   (TE (+ (F64 2.5) (F64 2.0)) (F64 4.5))
   (TE (- (S32 5)) (S32 -5))
   (TE (- (S32 8) (S32 9)) (S32 -1))
   (TE (- (F32 4.5f0) (F32 2.0f0)) (F32 2.5f0))
   (TE (- (F64 4.5) (F64 2.0)) (F64 2.5))
   (TE (* (S32 2) (S32 3)) (S32 6))
   (TE (* (F32 2.0f0) (F32 1.5f0)) (F32 3.0f0))
   (TE (* (F64 2.0) (F64 1.5)) (F64 3.0))
   (TE (/ (S32 -9) (S32 3)) (S32 -3))
   (TE (/ (U32 9) (U32 3)) (U32 3))
   (TE (/ (F32 3.0f0) (F32 1.5f0)) (F32 2.0f0))
   (TE (/ (F64 3.0) (F64 1.5)) (F64 2.0))
   (TE (% (S32 9) (S32 5)) (S32 4))
   (TE (% (F32 5.3f0) (F32 2.0f0)) (F32 1.3000002f0))
   (TE (% (F64 5.3) (F64 2.0)) (F64 1.2999999999999998))
   (TE (<< (S32 1) (S32 1)) (S32 2))
   (TE (>> (S32 -2) (S32 1)) (S32 -1))
   (TE (>> (U32 2) (U32 1)) (U32 1))
   (TE (bitwise-ior (S32 1) (S32 2)) (S32 3))
   (TE (bitwise-ior (U32 1) (U32 2)) (U32 3))
   (TE (bitwise-and (S32 3) (S32 1)) (S32 1))
   (TE (bitwise-and (U32 3) (U32 1)) (U32 1))
   (TE (bitwise-xor (S32 3) (S32 2)) (S32 1))
   (TE (bitwise-xor (U32 3) (U32 2)) (U32 1))
   (TE (= (S32 5) (S32 5)) (S32 1))
   (TE (= (F32 5.0f0) (F32 5.0f0)) (S32 1))
   (TE (= (F64 5.0) (F64 5.0)) (S32 1))
   (TE (!= (S32 5) (S32 5)) (S32 0))
   (TE (!= (F32 5.0f0) (F32 5.0f0)) (S32 0))
   (TE (!= (F64 5.0) (F64 5.0)) (S32 0))
   (TE (< (S32 2) (S32 3)) (S32 1))
   (TE (< (F32 2.0f0) (F32 3.0f0)) (S32 1))
   (TE (< (F64 2.0) (F64 3.0)) (S32 1))
   (TE (<= (S32 2) (S32 3)) (S32 1))
   (TE (<= (F32 2.0f0) (F32 3.0f0)) (S32 1))
   (TE (<= (F64 2.0) (F64 3.0)) (S32 1))
   (TE (> (S32 2) (S32 3)) (S32 0))
   (TE (> (F32 2.0f0) (F32 3.0f0)) (S32 0))
   (TE (> (F64 2.0) (F64 3.0)) (S32 0))
   (TE (>= (S32 2) (S32 3)) (S32 0))
   (TE (>= (F32 2.0f0) (F32 3.0f0)) (S32 0))
   (TE (>= (F64 2.0) (F64 3.0)) (S32 0))
   (TE (add1 (S32 3)) (S32 4))
   (TE (add1 (F32 3.0f0)) (F32 4.0f0))
   (TE (add1 (F64 3.0)) (F64 4.0))
   (TE (sub1 (S32 3)) (S32 2))
   (TE (sub1 (F32 3.0f0)) (F32 2.0f0))
   (TE (sub1 (F64 3.0)) (F64 2.0))
   (TE (and) (S8 1))
   (TE (and (S32 2)) (S32 2))
   (TE (and (S32 1) 2) (S32 2))
   (TE (and (S32 0) 2) (S32 0))
   (TE (or) (S8 0))
   (TE (or (S32 5)) (S32 5))
   (TE (or (S32 0) 0 (if 0 1 2)) (S32 2))
   (TE (or (S32 0) 5) (S32 5))
   (TS (let ([x : S32 := (S32 1)]) (+=1 x) x) (S32 2))
   (TS (let ([x : F32 := (F32 1f0)]) (+=1 x) x) (F32 2f0))
   (TS (let ([x : F64 := (F64 1.0)]) (+=1 x) x) (F64 2.0))
   (TS (let ([x : S32 := (S32 2)]) (-=1 x) x) (S32 1))
   (TS (let ([x : F32 := (F32 2f0)]) (-=1 x) x) (F32 1f0))
   (TS (let ([x : F64 := (F64 2.0)]) (-=1 x) x) (F64 1.0))
   ;; Cast
   (TE ((S8 23) : U32) (U32 23))
   (TE (let ([x : S8 := (S8 23)]) (x : U32)) (U32 23))
   (TE ((F64 23.3) : F32) (F32 23.3f0))
   (TE ((F64 23.3) : S32) (S32 23))
   (TE ((S32 23) : F64) (F64 23.0))
   ;; Simple unions
   (TE (let ([x : (union a S32 b S64) := (union a (S32 5))])
         (iadd (x as a) (S32 5)))
       (S32 10))
   ;; XXX How to test Fail?

   (TS (let ([x : S64 := (S64 1)])
         (void)
         x)
       (S64 1))
   (TS (let ([x : S64 := (S64 1)])
         {x <- (S64 5)}
         x)
       (S64 5))
   (TS (let ([x : S64 := (S64 1)])
         {x <- (iadd (S64 5) (S64 6))}
         x)
       (S64 11))
   (TS (begin (define x : S64 := (S64 0))
              (define y : S64 := (S64 0))
              {x <- (S64 1)} {y <- (S64 2)}
              (iadd x y))
       (S64 3))
   (TS (begin (define x : S64 := (S64 0))
              (define y : S64 := (S64 0))
              (if (ieq (S64 0) (S64 0))
                  {x <- (S64 1)}
                  {y <- (S64 2)})
              (iadd x y))
       (S64 1))
   (TS (begin (define x : S64 := (S64 0))
              (define y : S64 := (S64 0))
              (if (ieq (S64 0) (S64 1))
                  {x <- (S64 1)}
                  {y <- (S64 2)})
              (iadd x y))
       (S64 2))
   (TS (begin (define x : S64 := (S64 0))
              (while (islt x (S64 5))
                {x <- (iadd x (S64 1))})
              x)
       (S64 5))
   (TS (begin (define x : S64 := (S64 0))
              (define y : S64 := (S64 0))
              (while (islt x (S64 5))
                {y <- (iadd y x)}
                {x <- (iadd x (S64 1))})
              y)
       (S64 (+ (+ (+ (+ (+ 0 0) 1) 2) 3) 4)))

   (TS (begin
         (define x : S32 := (S32 0))
         (define y : S32 := (S32 1))
         (set! x (S32 0))
         (void)
         (unless (ieq x (S32 0))
           (error "The world is upside-down!"))
         (let/ec end
           (assert! #:dyn #:msg "y is positive"
                    (iult (S32 0) y))
           (if (ieq (S32 5) (S32 6))
               (set! x (S32 1))
               (set! y (S32 2)))
           (when (ieq y (S32 2))
             (set! x (S32 1))
             (end))
           (while (iult x (S32 6))
             (set! x (iadd x (S32 1)))))
         (set! y (S32 42))
         (iadd x y))
       (S32 43))

   (TS (begin
         (define x : U32 := (U32 0))
         {x <- (U32 100)}
         x)
       (U32 100))
   (TS (return (if (islt (U32 5) (U32 6))
                   (iadd (S64 2) (S64 3))
                   (isub (S64 5) (S64 6))))
       (S64 5))
   (TS (return (let ([x : U32 := (U32 5)])
                 (iadd x (U32 1))))
       (U32 6))

   (TS (begin (define my-array : (array 3 U32) := (array (U32 0) (U32 1) (U32 2)))
              (iadd (my-array @ (U32 0))
                    (iadd (my-array @ (U32 1))
                          (my-array @ (U32 2)))))
       (U32 (+ 0 1 2)))
   (TS (begin (define a : (array 3 U32) := (array (U32 0) (U32 1) (U32 2)))
              ((a @ (U32 0)) <- (U32 3))
              (a @ (U32 0)))
       (U32 3))
   (TS (begin (define y : S32 := (S32 5))
              (define my-array : (array 3 S32) := (zero (array 3 S32)))
              {y <- (iadd y (my-array @ (U32 2)))}
              y)
       (S32 5))
   ;; ABI for array arguments
   ;; XXX Can't trivially convert vector -> array for ABI right now.
   #;
   (TProg (define-fun (foo [arr : (array 3 S64)]) : S64
            (define a : S64 := (arr @ (U32 0)))
            (define b : S64 := (arr @ (U32 1)))
            (define c : S64 := (arr @ (U32 2)))
            (iadd a (iadd b c)))
          #:tests ["foo" (array (S64 2) (S64 3) (S64 4)) => (S64 9)])
   ;; Callee takes an array as an argument, assigns to it
   (TProg (define-fun S64 bar ([(array 3 S64) arr])
            ((arr @ (U32 0)) <- (S64 3))
            (S64 0))
          (define-fun S64 foo ()
            (define arr : (array 3 S64) := (array (S64 0) (S64 1) (S64 2)))
            (define z : S64 := bar <- arr)
            (arr @ (U32 0)))
          #:tests ["foo" => (S64 3)])
   (TProg (define-fun S64 bar ([S64 m])
            (iadd m (S64 1)))
          (define-fun S64 foo ([S64 n])
            (define a : S64 := bar <- n)
            a)
          #:tests ["foo" (S64 5) => (S64 6)])
   ;; Callee takes an integer argument by reference, assigns to it
   (let ([bar (F S64 ([#:ref S64 m])
                 (set! m (iadd m (S64 1)))
                 (S64 1))])
     (TProg (define-fun S64 foo ([S64 n])
              (define a : S64 := bar <- n)
              n)
            #:tests ["foo" (S64 5) => (S64 6)]))
   (TProg (define-fun S64 bar ([#:ref S64 m])
            (set! m (iadd m (S64 1)))
            (S64 1))
          (define-fun S64 foo ([S64 n])
            (define a : S64 := bar <- n)
            n)
          #:tests ["foo" (S64 5) => (S64 6)])
   ;; Private function
   (let ([c-add1 (F S32 ([S32 n]) (iadd n (S32 1)))])
     (TProg (define-fun S32 foo ([S32 x])
              (define r : S32 := c-add1 <- x)
              r)
            #:tests ["foo" (S32 5) => (S32 6)]))
   ;; Globals
   (TProg (define-global x : S32)
          (define-fun S32 foo ()
            (set! x (S32 5))
            (return x))
          #:tests ["foo" => (S32 5)])
   (TProg (define-global x : S32)
          (define-fun S32 set_x ()
            (set! x (S32 5))
            (return 0))
          (define-fun S32 plus_x ([S32 n])
            (+ n x))
          (define-fun S32 go ()
            (define z := set_x <-)
            (define n := plus_x <- (S32 3))
            n)
          #:tests ["go" => (S32 8)])
   (TProg (define-global x := (S32 5))
          (define-fun S32 plus_x ([S32 n])
            (+ n x))
          #:tests ["plus_x" (S32 3) => (S32 8)])
   (TProg (define-global x : S32 := 5)
          (define-fun S32 plus_x ([S32 n])
            (+ n x))
          #:tests ["plus_x" (S32 2) => (S32 7)])
   (TProg (define-global arr : (array 3 S32) := (array (S32 0) (S32 0) (S32 0)))
          (define-fun S32 set_arr ()
            (set! (arr @ 0) (S32 2))
            (set! (arr @ 1) (S32 3))
            (set! (arr @ 2) (S32 4))
            (return 0))
          (define-fun S32 arr_sum ()
            (+ (arr @ 0) (+ (arr @ 1) (arr @ 2))))
          (define-fun S32 go ()
            (define x := set_arr <-)
            (define y := arr_sum <-)
            y)
          #:tests ["go" => (S32 9)])
   (TProg (define-type arr_t (array 3 S32))
          (define-global arr := (arr_t (S32 1) (S32 2) (S32 3)))
          (define-fun S32 foo ()
            (+ (arr @ 0) (+ (arr @ 1) (arr @ 2))))
          #:tests ["foo" => (S32 6)])
   (TProg (define-type Coord (record x S32 y S32))
          (define-global crd : Coord := (Coord (S32 0) (S32 0)))
          (define-fun S32 set_crd ()
            (set! (crd -> x) 2)
            (set! (crd -> y) 3)
            (return 0))
          (define-fun S32 crd_sum ()
            (+ (crd -> x) (crd -> y)))
          (define-fun S32 go ()
            (define x := set_crd <-)
            (define y := crd_sum <-)
            (return y))
          #:tests ["go" => (S32 5)])
   ;; XXX Issue with evaling unions makes 2nd test fail.
   ;; How to handle unions being ref'd as different types
   ;; in evaluator?
   (TProg (define-type Num (union i S32 f F32))
          (define-global n := (Num #:i (S32 0)))
          (define-fun S32 set_i ()
            (set! (n as i) (S32 5))
            (return 0))
          (define-fun S32 go_i ()
            (define z := set_i <-)
            (n as i))
          (define-fun S32 set_f ()
            (set! (n as f) (F32 2.5f0))
            (return 0))
          (define-fun F32 go_f ()
            (define z := set_f <-)
            (n as f))
          #:tests ["go_i" => (S32 5)] #;["go_f" => (F32 2.5f0)])
   ;; Structs
   (let ([Coord (T (record x S64 y S64))])
     (TS (begin (define c : #,Coord := (record x (S64 5) y (S64 4)))
                (c -> x))
         (S64 5))
     (TS (begin (define c : #,Coord := (record x (S64 1) y (S64 2)))
                ((c -> x) <- (S64 3))
                (c -> x))
         (S64 3))
     (TProg (define-fun S64 bar ([#,Coord c])
              (c -> y))
            (define-fun S64 foo ([S64 n])
              (define p : #,Coord := (record x (S64 0) y n))
              (define m : S64 := bar <- p)
              m)
            #:tests ["foo" (S64 4) => (S64 4)])
     ;; Duplicate public type
     (TProg (include-type "Coord1" Coord)
            (include-type "Coord2" Coord)
            (define-fun S64 foo ([S64 n] [S64 m])
              (define c : #,Coord := (record x n y m))
              (iadd (c -> x) (c -> y)))
            #:tests ["foo" (S64 2) (S64 3) => (S64 5)])
     ;; XXX Can't return structs by pointer while they're compiled on stack.
     #;
     (TProg (define-fun (foo) : #,Coord
              (define c : #,Coord := (record x (S64 1) y (S64 2)))
              c)
            #:tests ["foo" => (record x (S64 1) y (S64 2))])
     ;; Fails with following sterr:
     ;;
     ;; SIGSEGV MAPPER si_code 1 fault on addr 0x1
     ;; Aborted (core dumped)
     ;;
     ;; Cause seems to be passing a record (struct) as an argument.
     #;
     (TProg (define-fun (foo [c : #,Coord]) : S64
              (c -> x))
            #:tests ["foo" (record x (S64 1) y (S64 2)) => (S64 1)])
     )
   ;; Test for F-expander syntax
   (TProg (define-fun S32 plus1 ([S32 n])
            (+ n 1))
          (define-fun S32 go ()
            (define x := (plus1 (S32 5)))
            x)
          #:tests ["go" => (S32 6)])
   (TProg (define-fun S32 square ([S32 n])
            (* n n))
          (define-fun S32 go ()
            (define x : S32 := (square (S32 5)))
            x)
          #:tests ["go" => (S32 25)])
   ;; Check for false positives on the type checker
   (TTN S8 128 -129)
   (TTN U8 256 -1)
   (TTN S16 (expt 2 15) (sub1 (- (expt 2 15))))
   (TTN U16 (expt 2 16) -1)
   (TTN S32 (expt 2 31) (sub1 (- (expt 2 31))))
   (TTN U32 (expt 2 32) -1)
   (TTN S64 (expt 2 63) (sub1 (- (expt 2 63))))
   (TTN U64 (expt 2 64) -1)
   (TTN F32 23.0 23)
   (TTN F64 23.0f0 23)
   (TTE (iadd (S32 5) (S64 5)))
   (TTE (fadd (S32 5) (S32 1)))
   (TTE (iadd (F32 5f0) (S32 2)))
   (TTE (let ([x : S32 := (S64 5)]) x))
   (TTE ((S32 5) : (array 1 S32)))
   (TTE (iadd (F32 5f0) (F32 6F0)))
   (TTE (fadd (S32 5) (S32 6)))
   (TTE (let ([x : S32 := (S64 5)]) x))
   (TTE (if (F32 2.3f0) (S32 1) (S32 2)))
   (TTE (if (S32 0) (S16 1) (U32 2)))
   (TTS (let ([x : S32 := (S32 1)])
          (x <- (U64 2))))
   (TTS (let ([x : (array 2 S32) := (array (S32 0) (S32 1))])
          ((x @ 0) <- (U64 2))))
   (TTS (if (F32 2.3f0) (void) (void)))
   (TTS (while (F32 23.f0) (void)))
   (TTS (let ([x : (array 2 S32) := (array (S32 0) (S32 1))])
          (while x (void))))
   (TTS (let ([x : S32 := (U64 5)]) (void)))
   (TTS (let ([x : (union a S32 b S64) := (S32 6)]) (void)))
   (TTS (let ([x : (array 2 S32) := (array (S32 1) (S32 2) (S32 3))]) (void)))
   (let ([square (F S32 ([S32 n]) (imul n n))])
     (TTS (let ([x : S32 := square <- (S32 5) (S32 6)]) (void)))
     (TTS (let ([x : S64 := square <- (S32 5)]) (void)))
     (TTS (let ([x : S32 := square <- (S64 5)]) (void)))
     (TTS (let ([x : S32 := square <- (S32 5)])
            (x <- (S64 10)))))
   (TT (F S32 ([S32 n])
          ((imul n n) : S64)))
   ;; ANF
   (syntax-parameterize ([F-body-default (make-rename-transformer #'S+)])
     (define-fun S32 square ([S32 n])
       (* n n))
     (define-type Coord (record x S32 y S32))
     (define-type Int/Flo (union i S32 f F32))
     (TS (+ (S32 2) (S32 3)) (S32 5))
     (TS (- (S32 5)) (S32 -5))
     (TS (- (S32 5) (S32 2)) (S32 3))
     (TS (* (S32 5) (S32 4)) (S32 20))
     (TS (/ (S32 9) (S32 3)) (S32 3))
     (TS (% (S32 9) (S32 5)) (S32 4))
     (TS (<< (S32 1) (S32 1)) (S32 2))
     (TS (>> (S32 -2) (S32 1)) (S32 -1))
     (TS (bitwise-ior (S32 1) (S32 2)) (S32 3))
     (TS (bitwise-and (S32 1) (S32 3)) (S32 1))
     (TS (bitwise-xor (S32 3) (S32 2)) (S32 1))
     (TS (= (S32 5) (S32 5)) (S32 1))
     (TS (!= (S32 5) (S32 5)) (S32 0))
     (TS (< (S32 2) (S32 3)) (S32 1))
     (TS (<= (S32 2) (S32 3)) (S32 1))
     (TS (> (S32 2) (S32 3)) (S32 0))
     (TS (>= (S32 2) (S32 3)) (S32 0))
     (TS (add1 (S32 1)) (S32 2))
     (TS (sub1 (S32 2)) (S32 1))
     (TS (let ([x (S32 2)] [y (S32 3)])
           (if (< x y) (+ x y) (error "x not less than y\n")))
         (S32 5))
     (TProg (define-fun S32 foo ([S32 x])
              (let/ec (esc S32)
                (if (< x 0) (esc x) (+ x (S32 2)))))
            #:tests
            ["foo" (S32 -1) => (S32 -1)]
            ["foo" (S32 1) => (S32 3)])
     (TProg (define-fun S32 foo ([S32 x])
              (let/ec (esc S32)
                (let ([y (S32 2)])
                  (if (< x 0)
                      (esc x)
                      (let ([z (S32 3)])
                        (* (+ x y) z))))))
            #:tests
            ["foo" (S32 -1) => (S32 -1)]
            ["foo" (S32 1) => (S32 9)])
     (TS (let ([n (S32 1)])
           (void) n)
         (S32 1))
     (TS (let ([n (S32 1)])
           (set! n (S32 5)) n)
         (S32 5))
     (TS (let ([n (S32 1)])
           (set! n 5) n)
         (S32 5))
     (TS (let ([x (S32 5)]) (square x)) (S32 25))
     (TS (let ([c (Coord (S32 2) (S32 3))])
           (* (c -> x) (c -> y)))
         (S32 6))
     (TS (let ([n (Int/Flo #:i (S32 5))]) (n as i)) (S32 5))
     (TS (let ([n (Int/Flo #:i (S32 1))] [c (Coord (S32 2) (S32 3))])
           (+ (n as i) (* (c -> x) (c -> y))))
         (S32 7))
     (TS (let ([n (let ([x (S32 2)] [c (Coord (S32 2) (S32 1))])
                    (+ x (+ (c -> x) (c -> y))))])
           (let ([m (Int/Flo #:i n)])
             (+ (m as i) (S32 1))))
         (S32 6))
     (TS #,(values '() (E (S32 5))) (S32 5))
     (TS (+ (S32 2) #,(values '() (E (S32 3)))) (S32 5))
     (TS (and) (S8 1))
     (TS (and (S32 2)) (S32 2))
     (TS (and (S32 1) 2) (S32 2))
     (TS (and (S32 0) 2) (S32 0))
     (TS (or) (S8 0))
     (TS (or (S32 5)) (S32 5))
     (TS (or (S32 0) 0 (if 0 1 2)) (S32 2))
     (TS (or (S32 0) 5) (S32 5))
     )
   ))
