#lang racket/base
(require adqc)
(module+ test
  (require (for-syntax racket/base
                       syntax/parse)
           chk
           (submod adqc/compile test)
           (submod adqc/eval test)))

;; XXX write a general `te/ts/tp` function that takes an
;; expr/stmt/program and tries to do all the things to it that make
;; sense.

(module+ test
  ;; eval-expr
  (define-syntax (go stx)
    (syntax-parse stx
      [(_ expect act (~optional (~seq #:env env) #:defaults ([env #'(hasheq)])))
       (quasisyntax/loc stx
         (chk (#:stx #,stx (eval-expr env (E act)))
              (#:stx #,stx (E expect))))]))
  ;; Integer arithmetic
  (go (S64 5) (S64 5))
  (go (S64 5) #,(Read (Var 'x (T S64)))
      #:env (hasheq 'x (box (E (S64 5)))))
  (go (S64 11) (iadd (S64 5) (S64 6)))
  (go (S64 11) (iadd #,(Read (Var 'x (T S64))) #,(Read (Var 'y (T S64))))
      #:env (hasheq 'x (box (E (S64 5))) 'y (box (E (S64 6)))))
  (go (S64 1) (isub (S64 6) (S64 5)))
  (go (S64 12) (imul (S64 3) (S64 4)))
  (go (U64 10) (iudiv (U64 100) (U64 10)))
  (go (S8 127) (iudiv (S8 -2) (S8 2)))
  (go (S8 127) (iudiv (S8 -1) (S8 2)))
  (go (S64 3) (isdiv (S64 13) (S64 4)))
  (go (S64 3) (isdiv (S64 12) (S64 4)))
  (go (S64 2) (isrem (S64 12) (S64 5)))
  (go (U64 5) (iurem (U64 105) (U64 10)))
  (go (S8 1) (iurem (S8 -1) (S8 2)))
  (go (S8 0) (iurem (S8 -2) (S8 2)))
  (go (S64 4) (ishl (S64 2) (S64 1)))
  (go (S64 2) (iashr (S64 4) (S64 1)))
  (go (S8 -32) (iashr (S8 -128) (S8 2)))
  (go (S8 32) (ilshr (S8 -128) (S8 2)))
  (go (U8 4) (ilshr (U8 16) (U8 2)))
  (go (S64 3) (ior (S64 1) (S64 2)))
  (go (U8 3) (ior (U8 1) (U8 2)))
  (go (S64 1) (iand (S64 3) (S64 1)))
  (go (U8 1) (iand (U8 3) (U8 1)))
  (go (S64 1) (ixor (S64 3) (S64 2)))
  (go (U8 1) (ixor (U8 3) (U8 2)))
  ;; Integer comparison
  (go (S64 1) (ieq (S64 1) (S64 1)))
  (go (S64 0) (ieq (S64 1) (S64 2)))
  (go (S64 1) (ine (S64 1) (S64 2)))
  (go (S64 0) (ine (S64 1) (S64 1)))
  (go (U8 1) (iugt (U8 5) (U8 4)))
  (go (U8 0) (iugt (U8 4) (U8 5)))
  (go (S8 1) (iugt (S8 -1) (S8 0)))
  (go (S8 1) (isgt (S8 1) (S8 0)))
  (go (S8 0) (isgt (S8 0) (S8 1)))
  (go (S8 1) (isgt (S8 0) (S8 -1)))
  (go (U8 1) (iuge (U8 1) (U8 1)))
  (go (S8 1) (iuge (S8 -1) (S8 0)))
  (go (S8 1) (isge (S8 1) (S8 1)))
  (go (S8 1) (isge (S8 1) (S8 -1)))
  (go (U8 1) (iult (U8 4) (U8 5)))
  (go (U8 0) (iult (U8 5) (U8 4)))
  (go (S8 1) (iult (S8 0) (S8 -1)))
  (go (S8 1) (islt (S8 0) (S8 1)))
  (go (S8 0) (islt (S8 1) (S8 0)))
  (go (S8 1) (islt (S8 -1) (S8 0)))
  (go (U8 1) (iule (U8 1) (U8 1)))
  (go (S8 1) (iule (S8 0) (S8 -1)))
  (go (S8 1) (isle (S8 1) (S8 1)))
  (go (S8 1) (isle (S8 -1) (S8 1)))
  ;; Floating point arithmetic
  ;; TODO: Add tests to check for appropriate FP rounding errors?
  (go (F64 3.5) (fadd (F64 2.0) (F64 1.5)))
  (go (F64 6.0) (fsub (F64 6.1) (F64 0.1)))
  (go (F64 2.25) (fmul (F64 1.5) (F64 1.5)))
  (go (F64 6.0) (fdiv (F64 9.0) (F64 1.5)))
  (go (F64 1.2999999999999998) (frem (F64 5.3) (F64 2.0)))
  ;; Floating point comparisons
  (go (U32 0) (ffalse (F64 +nan.0) (F64 +nan.0)))
  (go (U32 1) (ftrue (F64 +nan.0) (F64 +nan.0)))
  (go (U32 1) (foeq (F64 1.0) (F64 1.0)))
  (go (U32 0) (foeq (F64 1.0) (F64 2.0)))
  (go (U32 0) (foeq (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (fogt (F64 1.0) (F64 0.0)))
  (go (U32 0) (fogt (F64 0.0) (F64 1.0)))
  (go (U32 0) (fogt (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (foge (F64 1.0) (F64 1.0)))
  (go (U32 0) (foge (F64 0.0) (F64 1.0)))
  (go (U32 0) (foge (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (folt (F64 0.0) (F64 1.0)))
  (go (U32 0) (folt (F64 1.0) (F64 0.0)))
  (go (U32 0) (folt (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (fole (F64 1.0) (F64 1.0)))
  (go (U32 0) (fole (F64 1.0) (F64 0.0)))
  (go (U32 0) (fole (F64 1.0) (F64 +nan.0)))
  (go (U32 0) (fone (F64 1.0) (F64 1.0)))
  (go (U32 1) (fone (F64 0.0) (F64 1.0)))
  (go (U32 0) (fone (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (ford (F64 1.0) (F64 1.0)))
  (go (U32 0) (ford (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (fueq (F64 1.0) (F64 1.0)))
  (go (U32 0) (fueq (F64 0.0) (F64 1.0)))
  (go (U32 1) (fueq (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (fugt (F64 1.0) (F64 0.0)))
  (go (U32 0) (fugt (F64 0.0) (F64 1.0)))
  (go (U32 1) (fugt (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (fuge (F64 1.0) (F64 1.0)))
  (go (U32 0) (fuge (F64 0.0) (F64 1.0)))
  (go (U32 1) (fuge (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (fult (F64 0.0) (F64 1.0)))
  (go (U32 0) (fult (F64 1.0) (F64 0.0)))
  (go (U32 1) (fult (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (fule (F64 1.0) (F64 1.0)))
  (go (U32 0) (fule (F64 1.0) (F64 0.0)))
  (go (U32 1) (fule (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (fune (F64 0.0) (F64 1.0)))
  (go (U32 0) (fune (F64 1.0) (F64 1.0)))
  (go (U32 1) (fune (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (fueq (F64 1.0) (F64 1.0)))
  (go (U32 0) (fueq (F64 0.0) (F64 1.0)))
  (go (U32 1) (fueq (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (funo (F64 1.0) (F64 +nan.0)))
  (go (U32 0) (funo (F64 1.0) (F64 2.0)))
  ;; Cast
  (go (U32 23) ((S8 23) : U32))
  (go (F32 23.3f0) ((F64 23.3) : F32))
  (go (S32 23) ((F64 23.3) : S32))
  (go (F64 23.0) ((S32 23) : F64))
  ;; Fail
  (chk #:x (eval-expr (hasheq) (E (error "Fail Stmt"))) "Fail Stmt"))

#;
(module+ test
  (require chk)
  ;; eval-expr
  (chk (eval-expr (hash) 5)
       5)
  (chk (eval-expr (hash 'x 5) 'x)
       5)
  (chk (eval-expr (hash) (IBinOp 'iadd 5 6))
       11)
  (chk (eval-expr (hash 'x 5 'y 6) (IBinOp 'iadd 'x 'y))
       11)
  (chk (eval-expr (hash) (IBinOp 'isub 6 5))
       1)
  (chk (eval-expr (hash) (IBinOp 'imul 3 4))
       12)
  (chk #:t (> (eval-expr (hash) (IBinOp 'iudiv 10 -2)) 0))
  (chk (eval-expr (hash) (IBinOp 'isdiv 12 4))
       3)
  (chk (eval-expr (hash) (IBinOp 'isdiv 13 4))
       3)
  ;; TODO: What's the actual difference between signed
  ;; and unsigned remainder?
  (chk (eval-expr (hash) (IBinOp 'isrem 12 5))
       2)
  (chk (eval-expr (hash) (IBinOp 'ishl 2 1))
       4)
  (chk #:x (eval-expr (hash) (IBinOp 'ishl 2 -1))
       exn:fail:contract?)
  (chk (eval-expr (hash) (IBinOp 'iashr 4 1))
       2)
  (chk #:x (eval-expr (hash) (IBinOp 'iashr 2 -1))
       exn:fail:contract?)
  (chk (eval-expr (hash) (IBinOp 'ior 2 1))
       3)
  (chk (eval-expr (hash) (IBinOp 'iand 3 1))
       1)
  (chk (eval-expr (hash) (IBinOp 'ixor 3 2))
       1)
  (chk (eval-expr (hash) (ICmp 'ieq 1 1))
       1)
  (chk (eval-expr (hash) (ICmp 'ieq 1 0))
       0)
  (chk (eval-expr (hash) (ICmp 'ine 1 1))
       0)
  (chk (eval-expr (hash) (ICmp 'ine 1 0))
       1)
  (chk (eval-expr (hash) (ICmp 'iugt -1 5))
       1)
  (chk (eval-expr (hash) (ICmp 'iuge -1 5))
       1)
  (chk (eval-expr (hash) (ICmp 'iult 5 -1))
       1)
  (chk (eval-expr (hash) (ICmp 'iule 5 -1))
       1)
  (chk (eval-expr (hash) (ICmp 'isgt 1 0))
       1)
  (chk (eval-expr (hash) (ICmp 'isgt 0 1))
       0)
  (chk (eval-expr (hash) (ICmp 'isge 1 0))
       1)
  (chk (eval-expr (hash) (ICmp 'isge 1 1))
       1)
  (chk (eval-expr (hash) (ICmp 'isge 0 1))
       0)
  (chk (eval-expr (hash) (ICmp 'islt 0 1))
       1)
  (chk (eval-expr (hash) (ICmp 'islt 1 0))
       0)
  (chk (eval-expr (hash) (ICmp 'isle 0 1))
       1)
  (chk (eval-expr (hash) (ICmp 'isle 1 1))
       1)
  (chk (eval-expr (hash) (ICmp 'isle 1 0))
       0)
  (chk (eval-expr (hash) (And (ICmp 'islt 2 3)
                              (ICmp 'isge 3 3)))
       1)
  (chk (eval-expr (hash) (And (ICmp 'ieq 1 0)
                              (ICmp 'ine 1 0)))
       0)
  (chk (eval-expr (hash) (Or (ICmp 'islt 1 0)
                             (ICmp 'ieq 1 1)))
       1)
  (chk (eval-expr (hash) (Or (ICmp 'ieq 1 0)
                             (ICmp 'islt 1 0)))
       0)

  ;; eval-stmt
  (chk (eval-stmt (hash 'x 1) (Skip))
       (hash 'x 1))
  (chk (eval-stmt (hash) (Assign 'x 5))
       (hash 'x 5))
  (chk (eval-stmt (hash) (Assign 'x (IBinOp 'iadd 5 6)))
       (hash 'x 11))
  (chk (eval-stmt (hash) (Begin (Assign 'x 1) (Assign 'y 2)))
       (hash 'x 1 'y 2))
  (chk (eval-stmt (hash) (If (ICmp 'ieq 0 0) (Assign 'x 1) (Assign 'y 2)))
       (hash 'x 1))
  (chk (eval-stmt (hash) (If (ICmp 'ieq 0 1) (Assign 'x 1) (Assign 'y 2)))
       (hash 'y 2))
  (chk (eval-stmt (hash 'x 0) (While (ICmp 'islt 'x 5)
                                     ;(ICmp 'isle 'x 5)
                                     (Assign 'x (IBinOp 'iadd 'x 1))))
       (hash 'x 5))
  (chk (eval-stmt (hash 'x 0) (While (ICmp 'islt 'x 5)
                                     ;(ICmp 'isle 'x 5)
                                     (Begin (Assign 'x (IBinOp 'iadd 'x 1))
                                            (Assign 'y (IBinOp 'iadd 'x 'x)))))
       (hash 'x 5 'y 10))

  ;;TODO: Tests for check-pred.
  )

(module+ test
  (compile&emit
   (hasheq 'x "ecks" 'y "why")
   (let ([x (Var 'x (T S32))]
         [y (Var 'y (T S32))])
     (S
      (begin
        (set! x (S32 0))
        (void)
        (unless (ieq x (S32 0))
          (error "The world is upside-down!"))
        (let/ec end
          (assert! #:dyn #:msg "y is positive"
                   (iult (S32 0) y))
          (if (ieq (S32 5) (S32 6))
            (set! x (S32 1))
            (set! y (S32 2)))
          (when (ieq y (S32 2))
            (set! x (S32 1))
            (end))
          (while (iult x (S32 6))
            (set! x (iadd x (S32 1)))))
        (set! y (S32 42)))))))
