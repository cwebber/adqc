#lang racket/base
(require adqc)
(module+ test
  (require (for-syntax racket/base
                       syntax/parse)
           chk
           (submod adqc/compile test)
           (submod adqc/eval test)))

;; XXX write a general `te/ts/tp` function that takes an
;; expr/stmt/program and tries to do all the things to it that make
;; sense.

(module+ test
  ;; eval-expr
  (define-syntax (go stx)
    (syntax-parse stx
      [(_ expect act (~optional (~seq #:env env) #:defaults ([env #'(hasheq)])))
       (quasisyntax/loc stx
         (chk (#:stx #,stx expect)
              (#:stx #,stx (eval-expr env act))))]))
  ;; Integer arithmetic
  (go (S64 5) (S64 5))
  (go (S64 5) (Read (Var 'x S64T))
      #:env (hasheq 'x (box (S64 5))))
  (go (S64 11) (IAdd (S64 5) (S64 6)))
  (go (S64 11) (IAdd (Read (Var 'x S64T)) (Read (Var 'y S64T)))
      #:env (hasheq 'x (box (S64 5)) 'y (box (S64 6))))
  (go (S64 1) (ISub (S64 6) (S64 5)))
  (go (S64 12) (IMul (S64 3) (S64 4)))
  (go (U64 10) (IUDiv (U64 100) (U64 10)))
  (go (S8 127) (IUDiv (S8 -2) (S8 2)))
  (go (S8 127) (IUDiv (S8 -1) (S8 2)))
  (go (S64 3) (ISDiv (S64 13) (S64 4)))
  (go (S64 3) (ISDiv (S64 12) (S64 4)))
  (go (S64 2) (ISRem (S64 12) (S64 5)))
  (go (U64 5) (IURem (U64 105) (U64 10)))
  (go (S8 1) (IURem (S8 -1) (S8 2)))
  (go (S8 0) (IURem (S8 -2) (S8 2)))
  (go (S64 4) (IShl (S64 2) (S64 1)))
  (go (S64 2) (IAShr (S64 4) (S64 1)))
  (go (S8 -32) (IAShr (S8 -128) (S8 2)))
  (go (S8 32) (ILShr (S8 -128) (S8 2)))
  (go (U8 4) (ILShr (U8 16) (U8 2)))
  (go (S64 3) (IOr (S64 1) (S64 2)))
  (go (U8 3) (IOr (U8 1) (U8 2)))
  (go (S64 1) (IAnd (S64 3) (S64 1)))
  (go (U8 1) (IAnd (U8 3) (U8 1)))
  (go (S64 1) (IXor (S64 3) (S64 2)))
  (go (U8 1) (IXor (U8 3) (U8 2)))
  ;; Integer comparison
  (go (S64 1) (IEq (S64 1) (S64 1)))
  (go (S64 0) (IEq (S64 1) (S64 2)))
  (go (S64 1) (INe (S64 1) (S64 2)))
  (go (S64 0) (INe (S64 1) (S64 1)))
  (go (U8 1) (IUGt (U8 5) (U8 4)))
  (go (U8 0) (IUGt (U8 4) (U8 5)))
  (go (S8 1) (IUGt (S8 -1) (S8 0)))
  (go (S8 1) (ISGt (S8 1) (S8 0)))
  (go (S8 0) (ISGt (S8 0) (S8 1)))
  (go (S8 1) (ISGt (S8 0) (S8 -1)))
  (go (U8 1) (IUGe (U8 1) (U8 1)))
  (go (S8 1) (IUGe (S8 -1) (S8 0)))
  (go (S8 1) (ISGe (S8 1) (S8 1)))
  (go (S8 1) (ISGe (S8 1) (S8 -1)))
  (go (U8 1) (IULt (U8 4) (U8 5)))
  (go (U8 0) (IULt (U8 5) (U8 4)))
  (go (S8 1) (IULt (S8 0) (S8 -1)))
  (go (S8 1) (ISLt (S8 0) (S8 1)))
  (go (S8 0) (ISLt (S8 1) (S8 0)))
  (go (S8 1) (ISLt (S8 -1) (S8 0)))
  (go (U8 1) (IULe (U8 1) (U8 1)))
  (go (S8 1) (IULe (S8 0) (S8 -1)))
  (go (S8 1) (ISLe (S8 1) (S8 1)))
  (go (S8 1) (ISLe (S8 -1) (S8 1)))
  ;; Floating point arithmetic
  ;; TODO: Add tests to check for appropriate FP rounding errors?
  (go (F64 3.5) (FAdd (F64 2.0) (F64 1.5)))
  (go (F64 6.0) (FSub (F64 6.1) (F64 0.1)))
  (go (F64 2.25) (FMul (F64 1.5) (F64 1.5)))
  (go (F64 6.0) (FDiv (F64 9.0) (F64 1.5)))
  (go (F64 1.2999999999999998) (FRem (F64 5.3) (F64 2.0)))
  ;; Floating point comparisons
  (go (U32 0) (FFalse (F64 +nan.0) (F64 +nan.0)))
  (go (U32 1) (FTrue (F64 +nan.0) (F64 +nan.0)))
  (go (U32 1) (FOEq (F64 1.0) (F64 1.0)))
  (go (U32 0) (FOEq (F64 1.0) (F64 2.0)))
  (go (U32 0) (FOEq (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (FOGt (F64 1.0) (F64 0.0)))
  (go (U32 0) (FOGt (F64 0.0) (F64 1.0)))
  (go (U32 0) (FOGt (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (FOGe (F64 1.0) (F64 1.0)))
  (go (U32 0) (FOGe (F64 0.0) (F64 1.0)))
  (go (U32 0) (FOGe (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (FOLt (F64 0.0) (F64 1.0)))
  (go (U32 0) (FOLt (F64 1.0) (F64 0.0)))
  (go (U32 0) (FOLt (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (FOLe (F64 1.0) (F64 1.0)))
  (go (U32 0) (FOLe (F64 1.0) (F64 0.0)))
  (go (U32 0) (FOLe (F64 1.0) (F64 +nan.0)))
  (go (U32 0) (FONe (F64 1.0) (F64 1.0)))
  (go (U32 1) (FONe (F64 0.0) (F64 1.0)))
  (go (U32 0) (FONe (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (FOrd (F64 1.0) (F64 1.0)))
  (go (U32 0) (FOrd (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (FUEq (F64 1.0) (F64 1.0)))
  (go (U32 0) (FUEq (F64 0.0) (F64 1.0)))
  (go (U32 1) (FUEq (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (FUGt (F64 1.0) (F64 0.0)))
  (go (U32 0) (FUGt (F64 0.0) (F64 1.0)))
  (go (U32 1) (FUGt (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (FUGe (F64 1.0) (F64 1.0)))
  (go (U32 0) (FUGe (F64 0.0) (F64 1.0)))
  (go (U32 1) (FUGe (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (FULt (F64 0.0) (F64 1.0)))
  (go (U32 0) (FULt (F64 1.0) (F64 0.0)))
  (go (U32 1) (FULt (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (FULe (F64 1.0) (F64 1.0)))
  (go (U32 0) (FULe (F64 1.0) (F64 0.0)))
  (go (U32 1) (FULe (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (FUNe (F64 0.0) (F64 1.0)))
  (go (U32 0) (FUNe (F64 1.0) (F64 1.0)))
  (go (U32 1) (FUNe (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (FUEq (F64 1.0) (F64 1.0)))
  (go (U32 0) (FUEq (F64 0.0) (F64 1.0)))
  (go (U32 1) (FUEq (F64 1.0) (F64 +nan.0)))
  (go (U32 1) (FUno (F64 1.0) (F64 +nan.0)))
  (go (U32 0) (FUno (F64 1.0) (F64 2.0)))
  ;; Cast
  (go (U32 23) (Cast U32T (S8 23)))
  (go (F32 23.3f0) (Cast F32T (F64 23.3)))
  (go (S32 23) (Cast S32T (F64 23.3)))
  (go (F64 23.0) (Cast F64T (S32 23)))
  ;; Fail
  (chk #:x (eval-expr (hasheq) (Fail "Fail Stmt")) "Fail Stmt"))

#;
(module+ test
  (require chk)
  ;; eval-expr
  (chk (eval-expr (hash) 5)
       5)
  (chk (eval-expr (hash 'x 5) 'x)
       5)
  (chk (eval-expr (hash) (IBinOp 'iadd 5 6))
       11)
  (chk (eval-expr (hash 'x 5 'y 6) (IBinOp 'iadd 'x 'y))
       11)
  (chk (eval-expr (hash) (IBinOp 'isub 6 5))
       1)
  (chk (eval-expr (hash) (IBinOp 'imul 3 4))
       12)
  (chk #:t (> (eval-expr (hash) (IBinOp 'iudiv 10 -2)) 0))
  (chk (eval-expr (hash) (IBinOp 'isdiv 12 4))
       3)
  (chk (eval-expr (hash) (IBinOp 'isdiv 13 4))
       3)
  ;; TODO: What's the actual difference between signed
  ;; and unsigned remainder?
  (chk (eval-expr (hash) (IBinOp 'isrem 12 5))
       2)
  (chk (eval-expr (hash) (IBinOp 'ishl 2 1))
       4)
  (chk #:x (eval-expr (hash) (IBinOp 'ishl 2 -1))
       exn:fail:contract?)
  (chk (eval-expr (hash) (IBinOp 'iashr 4 1))
       2)
  (chk #:x (eval-expr (hash) (IBinOp 'iashr 2 -1))
       exn:fail:contract?)
  (chk (eval-expr (hash) (IBinOp 'ior 2 1))
       3)
  (chk (eval-expr (hash) (IBinOp 'iand 3 1))
       1)
  (chk (eval-expr (hash) (IBinOp 'ixor 3 2))
       1)
  (chk (eval-expr (hash) (ICmp 'ieq 1 1))
       1)
  (chk (eval-expr (hash) (ICmp 'ieq 1 0))
       0)
  (chk (eval-expr (hash) (ICmp 'ine 1 1))
       0)
  (chk (eval-expr (hash) (ICmp 'ine 1 0))
       1)
  (chk (eval-expr (hash) (ICmp 'iugt -1 5))
       1)
  (chk (eval-expr (hash) (ICmp 'iuge -1 5))
       1)
  (chk (eval-expr (hash) (ICmp 'iult 5 -1))
       1)
  (chk (eval-expr (hash) (ICmp 'iule 5 -1))
       1)
  (chk (eval-expr (hash) (ICmp 'isgt 1 0))
       1)
  (chk (eval-expr (hash) (ICmp 'isgt 0 1))
       0)
  (chk (eval-expr (hash) (ICmp 'isge 1 0))
       1)
  (chk (eval-expr (hash) (ICmp 'isge 1 1))
       1)
  (chk (eval-expr (hash) (ICmp 'isge 0 1))
       0)
  (chk (eval-expr (hash) (ICmp 'islt 0 1))
       1)
  (chk (eval-expr (hash) (ICmp 'islt 1 0))
       0)
  (chk (eval-expr (hash) (ICmp 'isle 0 1))
       1)
  (chk (eval-expr (hash) (ICmp 'isle 1 1))
       1)
  (chk (eval-expr (hash) (ICmp 'isle 1 0))
       0)
  (chk (eval-expr (hash) (And (ICmp 'islt 2 3)
                              (ICmp 'isge 3 3)))
       1)
  (chk (eval-expr (hash) (And (ICmp 'ieq 1 0)
                              (ICmp 'ine 1 0)))
       0)
  (chk (eval-expr (hash) (Or (ICmp 'islt 1 0)
                             (ICmp 'ieq 1 1)))
       1)
  (chk (eval-expr (hash) (Or (ICmp 'ieq 1 0)
                             (ICmp 'islt 1 0)))
       0)

  ;; eval-stmt
  (chk (eval-stmt (hash 'x 1) (Skip))
       (hash 'x 1))
  (chk (eval-stmt (hash) (Assign 'x 5))
       (hash 'x 5))
  (chk (eval-stmt (hash) (Assign 'x (IBinOp 'iadd 5 6)))
       (hash 'x 11))
  (chk (eval-stmt (hash) (Begin (Assign 'x 1) (Assign 'y 2)))
       (hash 'x 1 'y 2))
  (chk (eval-stmt (hash) (If (ICmp 'ieq 0 0) (Assign 'x 1) (Assign 'y 2)))
       (hash 'x 1))
  (chk (eval-stmt (hash) (If (ICmp 'ieq 0 1) (Assign 'x 1) (Assign 'y 2)))
       (hash 'y 2))
  (chk (eval-stmt (hash 'x 0) (While (ICmp 'islt 'x 5)
                                     ;(ICmp 'isle 'x 5)
                                     (Assign 'x (IBinOp 'iadd 'x 1))))
       (hash 'x 5))
  (chk (eval-stmt (hash 'x 0) (While (ICmp 'islt 'x 5)
                                     ;(ICmp 'isle 'x 5)
                                     (Begin (Assign 'x (IBinOp 'iadd 'x 1))
                                            (Assign 'y (IBinOp 'iadd 'x 'x)))))
       (hash 'x 5 'y 10))

  ;;TODO: Tests for check-pred.
  )

(module+ test
  (compile&emit
   (hasheq 'x "ecks" 'y "why")
   (S
    (begin
      (set! (Var 'x S32T) (S32 0))
      (void)
      (unless (IEq (Read (Var 'x S32T)) (S32 0))
        (error "The world is upside-down!"))
      (let/ec end
        (assert! #:dyn #:msg "y is positive"
                 (IULt (S32 0) (Read (Var 'y S32T))))
        (if (IEq (S32 5) (S32 6))
          (set! (Var 'x S32T) (S32 1))
          (set! (Var 'y S32T) (S32 2)))
        (when (IEq (Read (Var 'y S32T)) (S32 2))
          (set! (Var 'x S32T) (S32 1))
          (end))
        (while (IULt (Read (Var 'x S32T)) (S32 6))
          (set! (Var 'x S32T) (IAdd (Read (Var 'x S32T)) (S32 1)))))
      (set! (Var 'y S32T) (S32 42))))))
