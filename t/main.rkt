#lang racket/base
(require adqc)
(module+ test
  (require chk
           (submod adqc/compile test)))

;; XXX write a general `te/ts/tp` function that takes an
;; expr/stmt/program and tries to do all the things to it that make
;; sense.

(module+ test
  ;; eval-expr
  (chk (eval-expr (hash) (S64 5)) (S64 5))
  (chk (eval-expr (hash 'x (S64 5)) (Read (Var 'x S64T))) (S64 5))
  (chk (eval-expr (hash) (IAdd (S64 5) (S64 6))) (S64 11))
  (chk (eval-expr (hash 'x (S64 5) 'y (S64 6)) (IAdd (Read (Var 'x S64T)) (Read (Var 'y S64T)))) (S64 11))
  (chk (eval-expr (hash) (ISub (S64 6) (S64 5))) (S64 1))
  (chk (eval-expr (hash) (IMul (S64 3) (S64 4))) (S64 12))
  (chk #:t (> (Int-val (eval-expr (hash) (IUDiv (S64 10) (S64 -2)))) 0))
  (chk (eval-expr (hash) (ISDiv (S64 12) (S64 4))) (S64 3))
  (chk (eval-expr (hash) (ISDiv (S64 13) (S64 4))) (S64 3))
  ;; TODO: Unsigned remainder? What's the difference between signed/unsigned?
  (chk (eval-expr (hash) (ISRem (S64 12) (S64 5))) (S64 2))
  (chk (eval-expr (hash) (IShl (S64 2) (S64 1))) (S64 4))
  (chk #:x (eval-expr (hash) (IShl (S64 2) (S64 -1))) exn:fail:contract?)
  (chk (eval-expr (hash) (IAShr (S64 4) (S64 1))) (S64 2))
  (chk #:x (eval-expr (hash) IAShr (S64 4) (S64 -1)) exn:fail:contract?)
  (chk (eval-expr (hash) (IOr (S64 1) (S64 2))) (S64 3))
  (chk (eval-expr (hash) (IAnd (S64 3) (S64 1))) (S64 1))
  (chk (eval-expr (hash) (IXor (S64 3) (S64 2))) (S64 1))
  (chk (eval-expr (hash) (IEq (S64 1) (S64 1))) (S64 1))
  (chk (eval-expr (hash) (INe (S64 1) (S64 2))) (S64 1))
  ;; TODO: retyping unit tests is expensive...
  )

#;
(module+ test
  (require chk)
  ;; eval-expr
  (chk (eval-expr (hash) 5)
       5)
  (chk (eval-expr (hash 'x 5) 'x)
       5)
  (chk (eval-expr (hash) (IBinOp 'iadd 5 6))
       11)
  (chk (eval-expr (hash 'x 5 'y 6) (IBinOp 'iadd 'x 'y))
       11)
  (chk (eval-expr (hash) (IBinOp 'isub 6 5))
       1)
  (chk (eval-expr (hash) (IBinOp 'imul 3 4))
       12)
  (chk #:t (> (eval-expr (hash) (IBinOp 'iudiv 10 -2)) 0))
  (chk (eval-expr (hash) (IBinOp 'isdiv 12 4))
       3)
  (chk (eval-expr (hash) (IBinOp 'isdiv 13 4))
       3)
  ;; TODO: What's the actual difference between signed
  ;; and unsigned remainder?
  (chk (eval-expr (hash) (IBinOp 'isrem 12 5))
       2)
  (chk (eval-expr (hash) (IBinOp 'ishl 2 1))
       4)
  (chk #:x (eval-expr (hash) (IBinOp 'ishl 2 -1))
       exn:fail:contract?)
  (chk (eval-expr (hash) (IBinOp 'iashr 4 1))
       2)
  (chk #:x (eval-expr (hash) (IBinOp 'iashr 2 -1))
       exn:fail:contract?)
  (chk (eval-expr (hash) (IBinOp 'ior 2 1))
       3)
  (chk (eval-expr (hash) (IBinOp 'iand 3 1))
       1)
  (chk (eval-expr (hash) (IBinOp 'ixor 3 2))
       1)
  (chk (eval-expr (hash) (ICmp 'ieq 1 1))
       1)
  (chk (eval-expr (hash) (ICmp 'ieq 1 0))
       0)
  (chk (eval-expr (hash) (ICmp 'ine 1 1))
       0)
  (chk (eval-expr (hash) (ICmp 'ine 1 0))
       1)
  (chk (eval-expr (hash) (ICmp 'iugt -1 5))
       1)
  (chk (eval-expr (hash) (ICmp 'iuge -1 5))
       1)
  (chk (eval-expr (hash) (ICmp 'iult 5 -1))
       1)
  (chk (eval-expr (hash) (ICmp 'iule 5 -1))
       1)
  (chk (eval-expr (hash) (ICmp 'isgt 1 0))
       1)
  (chk (eval-expr (hash) (ICmp 'isgt 0 1))
       0)
  (chk (eval-expr (hash) (ICmp 'isge 1 0))
       1)
  (chk (eval-expr (hash) (ICmp 'isge 1 1))
       1)
  (chk (eval-expr (hash) (ICmp 'isge 0 1))
       0)
  (chk (eval-expr (hash) (ICmp 'islt 0 1))
       1)
  (chk (eval-expr (hash) (ICmp 'islt 1 0))
       0)
  (chk (eval-expr (hash) (ICmp 'isle 0 1))
       1)
  (chk (eval-expr (hash) (ICmp 'isle 1 1))
       1)
  (chk (eval-expr (hash) (ICmp 'isle 1 0))
       0)
  (chk (eval-expr (hash) (And (ICmp 'islt 2 3)
                              (ICmp 'isge 3 3)))
       1)
  (chk (eval-expr (hash) (And (ICmp 'ieq 1 0)
                              (ICmp 'ine 1 0)))
       0)
  (chk (eval-expr (hash) (Or (ICmp 'islt 1 0)
                             (ICmp 'ieq 1 1)))
       1)
  (chk (eval-expr (hash) (Or (ICmp 'ieq 1 0)
                             (ICmp 'islt 1 0)))
       0)

  ;; eval-stmt
  (chk (eval-stmt (hash 'x 1) (Skip))
       (hash 'x 1))
  (chk (eval-stmt (hash) (Assign 'x 5))
       (hash 'x 5))
  (chk (eval-stmt (hash) (Assign 'x (IBinOp 'iadd 5 6)))
       (hash 'x 11))
  (chk (eval-stmt (hash) (Begin (Assign 'x 1) (Assign 'y 2)))
       (hash 'x 1 'y 2))
  (chk (eval-stmt (hash) (If (ICmp 'ieq 0 0) (Assign 'x 1) (Assign 'y 2)))
       (hash 'x 1))
  (chk (eval-stmt (hash) (If (ICmp 'ieq 0 1) (Assign 'x 1) (Assign 'y 2)))
       (hash 'y 2))
  (chk (eval-stmt (hash 'x 0) (While (ICmp 'islt 'x 5)
                                     ;(ICmp 'isle 'x 5)
                                     (Assign 'x (IBinOp 'iadd 'x 1))))
       (hash 'x 5))
  (chk (eval-stmt (hash 'x 0) (While (ICmp 'islt 'x 5)
                                     ;(ICmp 'isle 'x 5)
                                     (Begin (Assign 'x (IBinOp 'iadd 'x 1))
                                            (Assign 'y (IBinOp 'iadd 'x 'x)))))
       (hash 'x 5 'y 10))

  ;;TODO: Tests for check-pred.
  )

(module+ test
  (compile&emit
   (hasheq 'x "ecks" 'y "why")
   (S
    (begin
      (set! (Var 'x S32T) (S32 0))
      (void)
      (unless (IEq (Read (Var 'x S32T)) (S32 0))
        (error "The world is upside-down!"))
      (let/ec end
        (assert! #:dyn #:msg "y is positive"
                 (IULt (S32 0) (Read (Var 'y S32T))))
        (if (IEq (S32 5) (S32 6))
          (set! (Var 'x S32T) (S32 1))
          (set! (Var 'y S32T) (S32 2)))
        (when (IEq (Read (Var 'y S32T)) (S32 2))
          (set! (Var 'x S32T) (S32 1))
          (end))
        (while (IULt (Read (Var 'x S32T)) (S32 6))
          (set! (Var 'x S32T) (IAdd (Read (Var 'x S32T)) (S32 1)))))
      (set! (Var 'y S32T) (S32 42))))))
